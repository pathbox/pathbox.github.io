---
layout: post
title: 最近工作总结(49)
date:  2021-05-06 20:00:00
categories: Work
image: /assets/images/post.jpg


---

​    

###Feed流设计简记

**存储**

我们先来看中间黑色框中的部分，这部分是使用TableStore的数据，从左往右分别是：

- 个人页Timeline：这个是每个用户的发件箱，也就是自己的个人页页面。
- 关注页Timeline：这个是每个用户的收件箱，也就是自己的关注页页面，内容都是自己关注人发布的消息。
- 关注列表：保存账号关系，比如朋友圈中的好友关系；微博中的关注列表等。
- 虚拟关注列表：这个主要用来个性化和广告

**发布Feed流程**

当你发布一条Feed消息的时候，流程是这样的：

1. Feed消息先进入一个队列服务。
2. 先从关注列表中读取到自己的粉丝列表，以及判断自己是否是大V。
3. 将自己的Feed消息写入个人页Timeline（发件箱）。如果是大V，写入流程到此就结束了。
4. 如果是普通用户，还需要将自己的Feed消息写给自己的粉丝，如果有100个粉丝，那么就要写给100个用户，包括Feed内容和Feed ID。
5. 第三步和第四步可以合并在一起，使用BatchWriteRow接口一次性将多行数据写入TableStore。
6. 发布Feed的流程到此结束。



> - 对大V采用拉模式，普通用户使用推模式，这种模式有个缺点，后面会有分析。
> - 对活跃粉丝采用推模式，非活跃粉丝采用拉模式（这种方式可以较好的避免大流量对平台的冲击）

**读取Feed流流程**

当刷新自己的Feed流的时候，流程是这样的：

1. 先去读取自己关注的大V列表
2. 去读取自己的收件箱，只需要一个GetRange读取一个范围即可，范围起始位置是上次读取到的最新Feed的ID，结束位置可以使当前时间，也可以是MAX，建议是MAX值。由于之前使用了主键自增功能，所以这里可以使用GetRange读取。
3. 如果有关注的大V，则再次并发读取每一个大V的发件箱，如果关注了10个大V，那么则需要10次访问。
4. 合并2和3步的结果，然后按时间排序，返回给用户。

至此，使用推拉结合方式的发布，读取Feed流的流程都结束了

https://developer.aliyun.com/article/224132



### 正则表达式的性能优化简记

正则表达式的原理是有穷自动机(**确定性有穷自动机**(DFA) **非确定性有穷自动机**（NFA）)

在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。

如何优化性能：

- **少用贪婪模式**：多用贪婪模式会引起回溯问题，可以使用独占模式来避免回溯

- **减少分支选择**：分支选择类型 “(X|Y|Z)” 的正则表达式会降低性能，在开发的时候要尽量减少使用。如果一定要用，可以通过以下几种方式来优化：

  1. 考虑选择的顺序，将比较常用的选择项放在前面，使他们可以较快地被匹配；

  2. 可以尝试提取共用模式，例如，将 “(abcd|abef)” 替换为 “ab(cd|ef)” ，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；

  3. 如果是简单的分支选择类型，可以用三次 index 代替 “(X|Y|Z)” ，如果测试话，你就会发现三次 index 的效率要比 “(X|Y|Z)” 高一些

- **减少捕获嵌套 ：**

  1. 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个（）就是一个捕获组，捕获组可以进行嵌套。

  2. 非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成

  

https://www.cnblogs.com/huangrenhui/p/13893903.html

https://www.cnblogs.com/he1m4n6a/p/10256163.html

### Rabbitmq死信队列存在的问题

如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行

**利用RabbitMQ插件实现延迟队列**
上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。
那如何解决这个问题呢？不要慌，安装一个插件即可：[https://www.rabbitmq.com/community-plugins.html](https://link.zhihu.com/?target=https%3A//www.rabbitmq.com/community-plugins.html) ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。
接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ



### JWT相对session的优势

session依赖缓存和数据库的存储，如果缓存和数据库挂了，很有可能导致用户无法登入

而JWT没有这种存储依赖，缓存和数据库挂了，在登入方面理论上依然可以正常进行

但jwt的缺点是：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

所以，要实现登出功能，还是需要存储JWT滴