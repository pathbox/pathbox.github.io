---
layout: post
title: 最近工作总结(49)
date:  2021-05-06 20:00:00
categories: Work
image: /assets/images/post.jpg


---

​    

###Feed流设计简记

**存储**

我们先来看中间黑色框中的部分，这部分是使用TableStore的数据，从左往右分别是：

- 个人页Timeline：这个是每个用户的发件箱，也就是自己的个人页页面。
- 关注页Timeline：这个是每个用户的收件箱，也就是自己的关注页页面，内容都是自己关注人发布的消息。
- 关注列表：保存账号关系，比如朋友圈中的好友关系；微博中的关注列表等。
- 虚拟关注列表：这个主要用来个性化和广告

**发布Feed流程**

当你发布一条Feed消息的时候，流程是这样的：

1. Feed消息先进入一个队列服务。
2. 先从关注列表中读取到自己的粉丝列表，以及判断自己是否是大V。
3. 将自己的Feed消息写入个人页Timeline（发件箱）。如果是大V，写入流程到此就结束了。
4. 如果是普通用户，还需要将自己的Feed消息写给自己的粉丝，如果有100个粉丝，那么就要写给100个用户，包括Feed内容和Feed ID。
5. 第三步和第四步可以合并在一起，使用BatchWriteRow接口一次性将多行数据写入TableStore。
6. 发布Feed的流程到此结束。



> - 对大V采用拉模式，普通用户使用推模式，这种模式有个缺点，后面会有分析。
> - 对活跃粉丝采用推模式，非活跃粉丝采用拉模式（这种方式可以较好的避免大流量对平台的冲击）

**读取Feed流流程**

当刷新自己的Feed流的时候，流程是这样的：

1. 先去读取自己关注的大V列表
2. 去读取自己的收件箱，只需要一个GetRange读取一个范围即可，范围起始位置是上次读取到的最新Feed的ID，结束位置可以使当前时间，也可以是MAX，建议是MAX值。由于之前使用了主键自增功能，所以这里可以使用GetRange读取。
3. 如果有关注的大V，则再次并发读取每一个大V的发件箱，如果关注了10个大V，那么则需要10次访问。
4. 合并2和3步的结果，然后按时间排序，返回给用户。

至此，使用推拉结合方式的发布，读取Feed流的流程都结束了

https://developer.aliyun.com/article/224132



### 正则表达式的性能优化简记

正则表达式的原理是有穷自动机(**确定性有穷自动机**(DFA) **非确定性有穷自动机**（NFA）)

在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。

如何优化性能：

- **少用贪婪模式**：多用贪婪模式会引起回溯问题，可以使用独占模式来避免回溯

- **减少分支选择**：分支选择类型 “(X|Y|Z)” 的正则表达式会降低性能，在开发的时候要尽量减少使用。如果一定要用，可以通过以下几种方式来优化：

  1. 考虑选择的顺序，将比较常用的选择项放在前面，使他们可以较快地被匹配；

  2. 可以尝试提取共用模式，例如，将 “(abcd|abef)” 替换为 “ab(cd|ef)” ，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；

  3. 如果是简单的分支选择类型，可以用三次 index 代替 “(X|Y|Z)” ，如果测试话，你就会发现三次 index 的效率要比 “(X|Y|Z)” 高一些

- **减少捕获嵌套 ：**

  1. 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个（）就是一个捕获组，捕获组可以进行嵌套。

  2. 非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成

  

https://www.cnblogs.com/huangrenhui/p/13893903.html

https://www.cnblogs.com/he1m4n6a/p/10256163.html

### Rabbitmq死信队列存在的问题

如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行

**利用RabbitMQ插件实现延迟队列**
上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。
那如何解决这个问题呢？不要慌，安装一个插件即可：[https://www.rabbitmq.com/community-plugins.html](https://link.zhihu.com/?target=https%3A//www.rabbitmq.com/community-plugins.html) ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。
接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ



### JWT相对session的优势

session依赖缓存和数据库的存储，如果缓存和数据库挂了，很有可能导致用户无法登入

而JWT没有这种存储依赖，缓存和数据库挂了，在登入方面理论上依然可以正常进行

但jwt的缺点是：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。

所以，要实现登出功能，还是需要存储JWT滴

### time.Duration 作为timeout参数类型，别传整数

在一些方法需要传入超时参数值，超时参数的类型是 time.Duration,当你传比如30，这不是表示30s超时，而是30纳秒，这样你的client请求可能还没进行第一次握手就超时了，这时会收到

```go
net/http: request canceled (Client.Timeout exceeded while awaiting headers)
```

的报错

正确使用方式参数值为: `30 * time.Second`

### Time Stamp Counter时间戳计数器

The **Time Stamp Counter** (**TSC**) **时间戳计数器**（**TSC**）是一个64位[寄存器](https://en.wikipedia.org/wiki/Processor_register)存在于所有[86](https://en.wikipedia.org/wiki/X86)自处理器[奔腾](https://en.wikipedia.org/wiki/Intel_P5)。它计算自复位以来的CPU[周期](https://en.wikipedia.org/wiki/Clock_rate)数。该指令`RDTSC`以EDX：EAX返回TSC。在[x86-64](https://en.wikipedia.org/wiki/X86-64)模式下，`RDTSC`还清除[RAX](https://en.wikipedia.org/wiki/RAX_register)和[RDX](https://en.wikipedia.org/wiki/RDX_register)的高32位。是一种更高性能的基于CPU获取时间戳的方式。它记录了 CPU 供电重设后到当前时刻所经过的 CPU 时钟周期数。在 CPU 时钟周期速率相同的条件下，经过测量和换算即可用于高精度计时。对于需要大量获取时间戳的操作，比如分布式链式追踪(opentracing)，日志打印等，如果能够使用这种方式获取时间戳信息，那么能够大大提升性能

https://en.wikipedia.org/wiki/Time_Stamp_Counter

https://github.com/dterei/gotsc

https://github.com/tikv/minitrace-go

https://www.jianshu.com/p/d57b12d18c98



###HTTPS实现原理
SSL建立连接过程

1. client向server发送请求https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。
2. server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。
3. 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。
4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。
5. 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。
6. 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7. 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。
8. 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。
9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了
    