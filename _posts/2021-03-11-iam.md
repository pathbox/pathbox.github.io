---
layout: post
title: 基于ABAC授权策略的IAM系统开发从0到1总结
date:  2021-03-11 20:00:00
categories: System
image: /assets/images/post.jpg



---

过去近一年主要的工作任务是基于ABAC授权策略的IAM系统开发，终于发布上线。

这是一个从0到1的经历过程，本文主要是个人对基于ABAC授权策略的IAM系统开发的流程和关键点的观点总结。



### IAM系统中的权限策略模型

[什么是IAM？](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/introduction.html)

> Identity and Access Management (IAM) 是一种 Web 服务，可以帮助您安全地控制对 AWS 资源的访问。您可以使用 IAM 控制对哪个用户进行身份验证 (登录) 和授权 (具有权限) 以使用资源。

在权限策略控制的设计中，更广为人知的是: **RBAC模型**。

RBAC认为权限授权的过程可以抽象地概括为：Who是否可以对What进行How的访问操作，并对这个逻辑表达式进行判断是否为True的求解过程，也即是将权限问题转换为What、How的问题，Who、What、How构成了访问权限三元组，也就是三个主要元素: 用户、角色和权限。

另一种模型是: **ABAC模型**。基于属性的访问控制（ABAC）是一种授权策略，基于属性来定义权限。

RBAC模型的简单明了和更贴近现实世界的逻辑场景能够满足大部分权限控制管理的需求。 

但是由于原有系统的RBAC模型已经无法满足我们实际产品中复杂和灵活的权限控制需求，所以我们决定开始了基于**ABAC模型**开发IAM系统。

之后文章讲的**IAM**都是指基于**ABAC模型**的**IAM**系统。



### AWS IAM是最好的产品资料

[AWS IAM产品](https://aws.amazon.com/cn/iam/)应该是IAM产品中的业界标杆。

- AWS足够复杂，有不同的登入方式，权限获取方式，权限控制的场景
- AWS IAM产品文档较完整

不了解基于ABAC模型的IAM具体是怎样的，对我们来说这是新的概念和知识。在对友商和业界标杆AWS IAM等产品进行调研和文档查阅后，对ABAC模型有了一定的认知。了解了IAM中有哪些重要的概念，能够应用于哪些场景，以及关键的要素和功能实现有可能的难点。



###思考IAM的底层设计架构

从认知到实现还有很长的一段路程。即使调研了主流友商的IAM产品，但是无法知道他们的底层设计是如何实现的。所以决定首先实现一个最简单的IAM系统。

最简单的IAM系统应该包括：

- 管理模块
- 鉴权模块

管理模块：管理IAM中需要的数据和实体，比如：用户管理、组管理、角色管理、策略管理。

鉴权模块：基于ABAC模型的策略鉴权方式。

策略是一个重要的元素。

> 策略是 IAM 中的对象；在与身份或资源相关联时，策略定义它们的权限。在委托人使用 IAM 实体（如用户或角色）发出请求时， 服务将评估这些策略。策略中的权限确定是允许还是拒绝请求。

一个策略大概是长这样：

```json
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": "dynamodb:*",
    "Resource": "arn:aws:dynamodb:us-east-2:123456789012:table/Books",
    "Condition":""
  }
}
```

策略其实就是我们制定的权限规则。在某个实体(例如用户)

鉴权模块：基于ABAC模型的策略鉴权方式。

在RBAC中的鉴权流程是: 角色是否有权限。 

在IAM ABAC中的鉴权流程是：请求是否匹配了策略。

按照现实世界的逻辑，**拥有权限**和**匹配策略**是两个不同的维度。**匹配策略**能够满足更复杂、灵活和细粒度的鉴权方式。



















- 元数据模块
- 兼容现有的权限系统，能够满足现有RABC权限模型迁移到IAM系统







定下初期目标:实现一个最简单的IAM系统。

IAM系统分成这几个模块:

- 管理模块
- 鉴权模块
- 系统元数据模块

管理模块：基本的用户管理、组管理、角色管理、策略管理等。

策略是一个重要的元素。

> 策略是 IAM 中的对象；在与身份或资源相关联时，策略定义它们的权限。在委托人使用 IAM 实体（如用户或角色）发出请求时， 服务将评估这些策略。策略中的权限确定是允许还是拒绝请求。

一个策略大概是长这样：

```json
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": "dynamodb:*",
    "Resource": "arn:aws:dynamodb:us-east-2:123456789012:table/Books",
    "Condition":""
  }
}
```

策略其实就是我们制定的权限规则。在某个实体(例如用户)

鉴权模块：基于ABAC模型的策略鉴权方式。

在RBAC中的鉴权流程是: 角色是否有权限。 

在IAM ABAC中的鉴权流程是：请求是否匹配了策略。

按照现实世界的逻辑，**拥有权限**和**匹配策略**是两个不同的维度。**匹配策略**能够满足更复杂、灵活和细粒度的鉴权方式。

系统元数据模块：对产品、接口、资源等元数据的管理和设计。

 这一部分非常重要，是实现一个好的IAM系统的底层支持。IAM系统中的关键对象是策略，它决定着ABAC的鉴权方式。而策略中的组成对象Action和Resource的定义，就是来源于产品、接口、资源，这一部分我们具体讲讲。

![         阐释这 3 个表以及它们之间关系的策略摘要图       ](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/policy_summaries-diagram.png)

 

可以这样理解：用户进行产品操作是通过调用接口的方式操作某资源进行增、删、改、查。

###一个简单的鉴权例子

我们发起了一个接口请求,参数是这样的:

```json
{
	"Action": "UpdateUFileName",
  "Name": "aaabbb",
  "ObjectID": 1
}
```

在鉴权的时候，假设查找到了对应的策略A。就需要将接口中的Action和策略A中的Action进行匹配(这里没有Resource，所以不用匹配)，如果匹配成功，就会执行Effect定义的相应Allow允许或Deny拒绝。如果没有匹配成功也是拒绝。

如果只是"单一的完全相等"的匹配，对于底层数据的支持要求很低，但这种匹配是无法实现灵活的功能的。

如果需要灵活方式的匹配，对于底层数据的支持要求很高。

在AWS 的策略定义中是支持通配符匹配的，比如： "Action": "dynamodb:*"。

接口设计，资源设计没有任何制定的规范规则，如何在策略定义中支持通配符匹配呢？

策略的定义是可以实现很灵活的匹配以满足实际需求，然而灵活并非无规则、无序。

假设我们这样规范一个接口的名称:  操作+产品+其他。拆解一下UpdateUFileName接口

- 操作：Update
- 产品：UFile
- 其他：Name

通过接口名称就能知道是什么操作了具体哪款产品。在策略中不就可以制定通配符匹配的规则了嘛。

```
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": "UFile:Update*"
  }
}
```

策略表示：UFile 产品的所有更新操作都允许。

同理Resource的匹配需要"资源系统"的支持。

看到这里需要明白一件事情。不是所有系统都需要IAM权限系统，大部分系统**RABC**模型就能很好的实现鉴权系统。

IAM权限系统需要底层接口设计、资源设计、属性设计的支持。如果没有，建议先进行底层数据架构的设计。



IAM产品的使用学习成本是有点高的，主要是在对策略的创建方面。因为策略匹配的灵活性，使用者可以组合出各种各样的权限。这样也就会产生一个问题：策略实现权限的重复和冲突。

我们的方案是：尽量在用户体验上做更多的优化，简化用户的操作，用尽可能简单的策略和组织来实现用户的需求。



###网关是重要的一环

在网关进行鉴权是大部分系统的选择方案。底层鉴权模式改了，原来存在的各种鉴权类型都需要能够兼容。所以，网关鉴权的改造是重要的一环。



###IAM的模型架构





夏天结束后，最简单的IAM系统代码编写基本完成。有一定时间审视过去的工作，查找过去的代码、架构设计、功能设计上出现的问题。在代码设计中，原先使用了正则匹配去实现策略的匹配规则。然而正则匹配的性能较低，决定寻找替代正则匹配的方案，于是找到了[通配符匹配](http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm)的方式，能够满足策略的匹配需求。  

```go
package benchmark

import (
	"path/filepath"
	"regexp"
	"testing"

	"github.com/gobwas/glob"
)

const (
	pattern_prefix                 = "abc*"
	regexp_prefix                  = `^abc.*$`
	pattern_suffix                 = "*def"
	regexp_suffix                  = `^.*def$`
	pattern_prefix_suffix          = "ab*ef"
	regexp_prefix_suffix           = `^ab.*ef$`
	fixture_prefix_suffix_match    = "abcdef"
	fixture_prefix_suffix_mismatch = "af"
)



func BenchmarkPrefixRegexpMatch(b *testing.B) {
	m := regexp.MustCompile("^aaa:bbb:.*:cccccc:myphotos/hangzhou/2015/.*$")
	f := []byte("aaa:bbb:b:cccccc:myphotos/hangzhou/2015/aaa")

	for i := 0; i < b.N; i++ {
		_ = m.Match(f)
	}
}

func BenchmarkPrefixFilepathMatch(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, _ = filepath.Match("aaa:bbb:*:cccccc:myphotos/hangzhou/2015/*", "aaa:bbb:b:cccccc:myphotos/hangzhou/2015/aaa")
	}
}

func BenchmarkPrefixGlobMatch(b *testing.B) {
	var g glob.Glob

	// create simple glob
	g = glob.MustCompile("aaa:bbb:*:cccccc:myphotos/hangzhou/2015/*")

	for i := 0; i < b.N; i++ {
		g.Match("aaa:bbb:b:cccccc:myphotos/hangzhou/2015/aaa") // true
	}
}


func BenchmarkSuffixRegexpMatch(b *testing.B) {
	m := regexp.MustCompile("^.*:aaa:abcabcabc")
	f := []byte("123:aaa:abcabcabc")

	for i := 0; i < b.N; i++ {
		_ = m.Match(f)
	}
}

func BenchmarkSuffixFilepathMatch(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, _ = filepath.Match("*:aaa:abcabcabc", "123:aaa:abcabcabc")
	}
}

func BenchmarkSuffixGlobMatch(b *testing.B) {
	var g glob.Glob

	// create simple glob
	g = glob.MustCompile("*:aaa:abcabcabc")

	for i := 0; i < b.N; i++ {
		g.Match("123:aaa:abcabcabc") // true
	}
}


func BenchmarkPrefixSuffixRegexpMatch(b *testing.B) {
	m := regexp.MustCompile(regexp_prefix_suffix)
	f := []byte(fixture_prefix_suffix_match)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = m.Match(f)
	}
}

func BenchmarkPrefixSuffixFilepathMatch(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, _ = filepath.Match(pattern_prefix_suffix, fixture_prefix_suffix_match)
	}
}

func BenchmarkPrefixSuffixGlobMatch(b *testing.B) {
	var g glob.Glob

	// create simple glob
	g = glob.MustCompile(pattern_prefix_suffix)

	for i := 0; i < b.N; i++ {
		g.Match(fixture_prefix_suffix_match) // true
	}
}

// go test -bench=. benchmark_test.go

/*
goos: darwin
goarch: amd64
BenchmarkPrefixRegexpMatch-4              695192              2333 ns/op
BenchmarkPrefixFilepathMatch-4           3774104               404 ns/op
BenchmarkPrefixGlobMatch-4              20142326                71.3 ns/op
BenchmarkSuffixRegexpMatch-4             1470373               713 ns/op
BenchmarkSuffixFilepathMatch-4          10244230               103 ns/op
BenchmarkSuffixGlobMatch-4              147599737                7.88 ns/op
BenchmarkPrefixSuffixRegexpMatch-4       4915987               228 ns/op
BenchmarkPrefixSuffixFilepathMatch-4    19263058                61.9 ns/op
BenchmarkPrefixSuffixGlobMatch-4        90101554                13.0 ns/op
PASS
ok      command-line-arguments  13.843s
*/
```

上述是一个通配符匹配库glob和正则匹配的一个benchmark，可以看到匹配性能提升了20倍以上





### 数据迁移方案

由于有许多新表的生成，对旧表的数据需要迁移到新表，通过编写脚本进行迁移。支持按用户单个或批量迁移，保证在用户使用IAM系统之前，旧的数据需要迁移完成即可。









调研IAM => 设计IAM服务系统框架和权限系统 => 实现最简单的IAM系统 => 解决bug，进行调整，增加更多的功能 => 迁移旧的权限系统数据到新的IAM => 测试 => 灰度上线





[ABAC 与传统 RBAC 模型的对比](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/introduction_attribute-based-access-control.html)





