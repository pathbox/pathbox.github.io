---
layout: post
title: 最近工作总结(43)
date:  2020-11-05 20:15:06
categories: Work
image: /assets/images/post.jpg

---

 

### 理解redis的单线与多线程程操作

IO多路复用程序接收到用户的请求后，全部推送到一个队列里，交给文件分派器。对于后续的操作，基于 Reactor 单线程模式实现， 整个过程都在一个线程里完成，因此 Redis 被称为是单线程的操作

![img](https://img-blog.csdnimg.cn/img_convert/b64cf42106d8fa3719e88b797d427a25.png)

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。**尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都推到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O多路复用程序才会继续向文件事件分派器传送下一个套接字**。

虽然**整个文件事件处理器是在单线程上运行的**，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD(文件描述符) 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单

Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用可以解决这个问题。但是对于大键值对这种情况，本身命令执行需要消耗大量时间，这样会阻塞redis主线程的执行，导致redis性能的下降，这种情况应该尽量避免

> https://hogwartsrico.github.io/2020/06/24/Redis-and-Multiplexing/



### Rabbitmq 一个消息并行事务如何实现

> exchange有多个种类，常用的有direct，fanout，topic。前三种类似集合对应关系那样，（direct）1:1,（fanout）1：N,（topic）N:1。direct： 1:1类似完全匹配
>
> fanout：1：N  可以把一个消息并行发布到多个队列上去，简单的说就是，当多个队列绑定到fanout的交换器,那么交换器一次性拷贝多个消息分别发送到绑定的队列上，每个队列有这个消息的副本。
>
> ```
> ps：这个可以在业务上实现并行处理多个任务，比如，用户上传图片功能，当消息到达交换器上，它可以同时路由到积分
> 增加队列和其它队列上，达到并行处理的目的，并且易扩展，以后有什么并行任务的时候，直接绑定到fanout交换器
> 不需求改动之前的代码。
> 复制代码
> ```
>
> topic   N:1 ，多个交换器可以路由消息到同一个队列。根据模糊匹配，比如一个队列的routing key 为*.test ，那么凡是到达交换器的消息中的routing key 后缀.test都被路由到这个队列上

当队列拥有多个消费者时，队列收到的消息将以轮询(负载均衡)的方式发送给消费者。每条消息只会发送给一个订阅的消费者

所以，如果想要将对消息进行并行处理事务 ，需要选择exchange fanout的模式，并且使用多个队列。没有办法通过一个队列多个消费者实现





### Linux系统为什么分系统空间和用户空间

1. 操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的;
   1. 分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性，并且管理上很方便;

3. 也是重要的一点，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统



### 一篇关于ETCD 数据不一致排查牛逼的文章

> https://stor.51cto.com/art/202004/615374.htm



### Redis做分布式锁的问题

1. **B的锁被A给释放了**：每个线程加锁时要带上自己独有的value值来标识

2. **数据库事务超时**：一旦你的key长时间获取不到锁，获取锁等待的时间远超过数据库事务超时时间，数据库事务超时了，但是锁还没超时，程序就会报异常。(Java中会遇到，将事务改成手动提交和回滚)

3. **锁过期了，业务还没执行完**：类似redisson在加锁成功后，会注册一个定时任务监听这个锁，每隔10秒就去查看这个锁，如果还持有锁，就对过期时间进行续期。默认过期时间30秒。对正在持有的锁进行续期操作

4. **Redis主从复制**：redis cluster集群环境下，假如现在A客户端想要加锁，它会根据路由规则选择一台master节点写入key mylock，在加锁成功后，master节点会把key异步复制给对应的slave节点。

   如果此时redis master节点宕机，为保证集群可用性，会进行主备切换，slave变为了redis master。B客户端在新的master节点上加锁成功，而A客户端也以为自己还是成功加了锁的。

   此时就会导致同一时间内多个客户端对一个分布式锁完成了加锁，导致各种脏数据的产生。

   如果只是一个redis cluster的方式做分布式锁，这种问题无法避免，所以有了RedLock的分布式锁方案，**多节点redis实现的分布式锁算法(RedLock):有效防止单点故障**。但是会引入RedLock自身的一些问题，需要具体权衡



